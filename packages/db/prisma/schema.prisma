generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

enum ExistingPlan {
  FREE
  PRO
  ENTERPRISE
}

model User {
  id          String       @id @default(cuid())
  githubId    String       @unique
  username    String
  email       String
  image       String
  activeRepos Int          @default(0)
  planName    ExistingPlan @default(FREE)
  planId      String
  plan        Plan         @relation(fields: [planId], references: [id])
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  repos       Repo[]
  payments    Payment[]
  role        Role         @default(USER)
  tokenCount  Int          @default(0)

  @@index([githubId])
  @@index([email])
  @@index([planId])
}

model Plan {
  id                       String       @id @default(cuid())
  name                     ExistingPlan @unique @default(FREE)
  price                    Float
  maxRepos                 Int
  aiReviewEnabled          Boolean      @default(false)
  aiIssueTriageEnabled     Boolean      @default(false)
  maxRepoIssueEmbedding    Int
  issueEmbedEnabled        Boolean      @default(false)
  pathConfigCustomization  Boolean      @default(false)
  labelConfigCustomization Boolean      @default(false)
  embeddingRepoContext     Boolean      @default(false)
  maxMonthlyReview         Int          @default(50)
  description              String
  createdAt                DateTime     @default(now())
  updatedAt                DateTime     @updatedAt
  payments                 Payment[]
  User                     User[]
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

model Payment {
  id         String        @id @default(cuid())
  pidx       String        @unique
  userId     String
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  status     PaymentStatus
  amount     Float
  planId     String
  plan       Plan          @relation(fields: [planId], references: [id], onDelete: Cascade)
  validUntil DateTime?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  @@index([userId])
  @@index([planId])
  @@index([status])
}

model Repo {
  id             String   @id @default(cuid())
  repoId         String   @unique
  repoName       String
  repoFullName   String
  repoURL        String
  languages      String[]
  installationId String
  isActive       Boolean  @default(false)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  repoConfig RepoConfig?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tokenCount Int @default(0)

  @@index([userId])
  @@index([repoId])
}

model RepoConfig {
  id String @id @default(cuid())

  repoId String @unique
  repo   Repo   @relation(fields: [repoId], references: [id], onDelete: Cascade)

  generalConfigId String        @unique
  generalConfig   GeneralConfig @relation(fields: [generalConfigId], references: [id], onDelete: Cascade)

  reviewConfigId String       @unique
  reviewConfig   ReviewConfig @relation(fields: [reviewConfigId], references: [id], onDelete: Cascade)

  issueConfigId String      @unique
  issueConfig   IssueConfig @relation(fields: [issueConfigId], references: [id])

  errorLogs RepoErrorLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([repoId])
  @@index([generalConfigId])
  @@index([reviewConfigId])
  @@index([issueConfigId])
}

model IssueConfig {
  id                   String  @id @default(cuid())
  aiIssueTriageEnabled Boolean @default(true)
  issueEmbedEnabled    Boolean @default(false)

  issueEnabled Boolean     @default(true)
  RepoConfig   RepoConfig?
}

enum Tone {
  professional
  casual
  friendly
  humorous
  enthusiastic
  empathetic
  formal
  informal
}

model GeneralConfig {
  id             String  @id @default(cuid())
  tone           Tone    @default(professional)
  enableFreeTier Boolean @default(true)
  earlyAccess    Boolean @default(false)
  defaultModel   String?

  contextDepth Int?

  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  RepoConfig RepoConfig?
}

model ReviewConfig {
  id                       String  @id @default(cuid())
  aiReviewEnabled          Boolean @default(false) // not true for FREE Plan
  highLevelSummaryEnabled  Boolean @default(true)
  showWalkThrough          Boolean @default(true)
  abortOnClose             Boolean @default(true)
  isProgressFortuneEnabled Boolean @default(false)
  poemEnabled              Boolean @default(false)

  // pathConfigs  PathConfig[]
  // labelConfigs LabelConfig[]
  RepoConfig RepoConfig?
}

model RepoErrorLog {
  id           String     @id @default(cuid())
  repoConfigId String
  repoConfig   RepoConfig @relation(fields: [repoConfigId], references: [id], onDelete: Cascade)
  message      String
  type         String // e.g. "suggestion", "review", "embedding", "labelTag"
  number       Int?
  occurredAt   DateTime   @default(now())
  resolved     Boolean    @default(false)
}

// TODO: FOR FUTURE IMPROVEMENT
// model PathConfig {
//   id             String        @id @default(cuid())
//   importance     Int?
//   pathPattern    String
//   instructions   String?
//   enabled        Boolean       @default(true)
//   createdAt      DateTime      @default(now())
//   updatedAt      DateTime      @updatedAt
//   ReviewConfig   ReviewConfig? @relation(fields: [reviewConfigId], references: [id])
//   reviewConfigId String?
// }

// To match the label from Github and pass instruction to LLM model
// model LabelConfig {
//   id             String        @id @default(cuid())
//   label          String
//   instructions   String?
//   enabled        Boolean       @default(true)
//   createdAt      DateTime      @default(now())
//   updatedAt      DateTime      @updatedAt
//   ReviewConfig   ReviewConfig? @relation(fields: [reviewConfigId], references: [id])
//   reviewConfigId String?
// }
